// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: screening.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const endScreening = `-- name: EndScreening :execresult
update broadcasts.screening set ended_at = now()
where screening.id = $1
    and screening.ended_at is null
`

func (q *Queries) EndScreening(ctx context.Context, screeningID uuid.UUID) (sql.Result, error) {
	return q.db.ExecContext(ctx, endScreening, screeningID)
}

const getScreeningHistory = `-- name: GetScreeningHistory :many
select
    screening.tape_id,
    array_agg(
        distinct screening.broadcast_id
        order by screening.broadcast_id
    )::integer[] as broadcast_ids
from broadcasts.screening
group by screening.tape_id
order by screening.tape_id
`

type GetScreeningHistoryRow struct {
	TapeID       int32
	BroadcastIds []int32
}

func (q *Queries) GetScreeningHistory(ctx context.Context) ([]GetScreeningHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getScreeningHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScreeningHistoryRow
	for rows.Next() {
		var i GetScreeningHistoryRow
		if err := rows.Scan(&i.TapeID, pq.Array(&i.BroadcastIds)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startScreening = `-- name: StartScreening :one
insert into broadcasts.screening (
    id,
    broadcast_id,
    tape_id,
    started_at
) values (
    gen_random_uuid(),
    $1,
    $2,
    now()
)
returning screening.id, screening.started_at
`

type StartScreeningParams struct {
	BroadcastID int32
	TapeID      int32
}

type StartScreeningRow struct {
	ID        uuid.UUID
	StartedAt time.Time
}

func (q *Queries) StartScreening(ctx context.Context, arg StartScreeningParams) (StartScreeningRow, error) {
	row := q.db.QueryRowContext(ctx, startScreening, arg.BroadcastID, arg.TapeID)
	var i StartScreeningRow
	err := row.Scan(&i.ID, &i.StartedAt)
	return i, err
}
